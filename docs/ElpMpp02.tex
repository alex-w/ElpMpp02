\documentclass[12pt]{article}
\usepackage[margin=0.8in,top=0.8in,bottom=0.8in]{geometry}
\usepackage{graphicx}
%\usepackage{float}
\usepackage{hyperref}
\newcommand \beq {\begin{equation}}
\newcommand \eeq {\end{equation}}
\newcommand \beqn {\begin{eqnarray}}
\newcommand \eeqn {\end{eqnarray}}
\newcommand{\ve}[1]{\mbox{\boldmath $#1$}}

\begin{document}
\title{ELP/MPP02 Lunar Ephemeris}
\author{\href{https://publish.illinois.edu/ytliu/}{Yuk Tung Liu}}
\date{2018-08-14}
\maketitle

%\begin{center}
%\href{https://publish.illinois.edu/ytliu/}{Yuk Tung Liu}
%\end{center}

ELP/MPP02 is a semi-analytic solution for the lunar motion developed by 
J. Chapront and G. Francou in 2002. It is an improvement of the ELP2000-82B 
lunar theory. The major paper about the ELP/MPP02 theory is 
{\it The lunar theory ELP revisited. 
Introduction of new planetary perturbations} by J.\ Chapront and G.\ Francou, 
\href{https://ui.adsabs.harvard.edu/abs/2003A%26A...404..735C/abstract}{Astronomy and Astrophysics, 
v.404, p.735-742 (2003)}, which you can also find references to the ELP2000-82B 
theory. The authors provide data files, a FORTRAN code and a 
pdf documentation on \href{ftp://cyrano-se.obspm.fr/pub/2_lunar_solutions/2_elpmpp02/}{this 
ftp site}. ELP/MPP02 theory provides two sets of parameters adjusted to fit 
either the lunar laser ranging (LLR) observation data or JPL's DE405/DE406 
ephemerides.

I have written C++ functions to compute the lunar positions based on  
the information on that ftp site. The full ELP/MPP02 theory contains 
series involving 35901 terms. High accuracy of lunar positions 
may not be necessary for some applications. It is therefore useful to create 
a truncated series to speed up computation. I have written routines 
that create a truncated series using 4 parameters. I 
also wrote a function to estimate the accuracy of the truncated series. 

JavaScript is convenient for HTML-based applications, such as my
\href{https://ytliu0.github.io/starCharts/}{local star charts} and
\href{https://ytliu0.github.io/starCharts/chartGCRS_min.html}{equatorial star
charts} pages. I wrote C++ routines that generate JavaScript functions to compute a truncated ELP/MPP02 series.

%The following is a summary of the files in this package.
%
%\begin{itemize}
%\item 14 data files: {\tt elp\_main.long}, {\tt elp\_main.lat}, {\tt elp\_main.dist}, 
%{\tt elp\_pert.longT0}, {\tt elp\_pert.longT1}, {\tt elp\_pert.longT2}, {\tt elp\_pert.longT3}, 
%{\tt elp\_pert.latT0}, {\tt elp\_pert.latT1}, {\tt elp\_pert.latT2}, {\tt elp\_pert.distT0}, 
%{\tt elp\_pert.distT1}, {\tt elp\_pert.distT2}, {\tt elp\_pert.distT3}. These data 
%files are generated from the data files in the ftp site mentioned above. They are 
%stored in a format that is more convenient for C++ implementation.
%
%\item {\tt ElpMpp02.h}: Contains functions that compute the lunar positions 
%using both sets of parameters fitted to LLR and DE405/DE406. This is basically 
%a C++ version of the FORTRAN code. The file {\tt example.cpp} provides 
%an example of using this code.
%
%\item {\tt ElpMpp\_trim.h}: Contains functions that generate a truncated 
%version of the ELP/MPP02 series. A C++ file and 14 data files will be created 
%by the code to implement the truncated series. It also contains a function that 
%estimates the accuracy of the truncated series by performing a Monte Carlo 
%simulation. The file {\tt example\_usingElpMpp\_trim.cpp} provides an example 
%of using this code.
%
%\item {\tt ElpMpp\_JavaScript.h}: Contains routines that create JavaScript 
%functions to compute a truncated ELP/MPP02 series. Two javascript files will be 
%created by this code. They contain exactly the same functions, but one is 
%human-readable and the other is a minified version (for production run). 
%No data files will be generated. Terms in the ELP/MPP02 series are written 
%explicitly in the JavaScript code. 
%
%\item {\tt ElpMpp02.html}: A web-based JavaScript calculator that computes 
%the lunar positions by ELP/MPP02 using both sets of parameters fitted to 
%LLR and DE405/DE406. This is essentially a JavaScript version of the 
%FORTRAN code. It is intended for code test.
%
%\item {\tt ElpMpp02\_aux.js}, {\tt ElpMpp02LLR\_min.js}, {\tt ElpMpp02DE\_min.js}: 
%Contain JavaScript functions used by {\tt ElpMpp02.html}. {\tt ElpMpp02LLR\_min.js} 
%and {\tt ElpMpp02DE\_min.js} are generated by {\tt ElpMpp\_JavaScript.h} to 
%compute the (untruncated) ELP/MPP02 series using parameters fitted to LLR and 
%DE405/DE406. {\tt ElpMpp02\_aux.js} contains auxiliary functions to manage the 
%activities on {\tt ElpMpp02.html}.
%
%\item {\tt ElpMpp02.css}: Style file used by {\tt ElpMpp02.html}.
%\end{itemize}

This document describes my implementation of the ELP/MPP02 series, 
the creation of a truncated series, and the estimation of the accuracy 
of the truncated series. I do not explain the ELP/MPP02 theory in this 
document. Readers who are interested in the theory can read the paper and 
the pdf document on the ftp site mentioned above.

\section{Implementation of ELP/MPP02} 

The equations for computing the ELP/MPP02 are given in the pdf document 
on \href{ftp://cyrano-se.obspm.fr/pub/2_lunar_solutions/2_elpmpp02/}{this ftp site}. 
In this section, I rewrite the equations in a form that is more convenient 
for code development.

\subsection{Parameters Adjusted to Fit LLR or DE405/DE406}

The following are values of the parameters adjusted to fit LLR or DE405/DE406. 
I use the same notation as in the pdf document on 
\href{ftp://cyrano-se.obspm.fr/pub/2_lunar_solutions/2_elpmpp02/}{this ftp site}. 
\vskip 0.5cm
\begin{tabular}{cccc} 
\hline
 {\bf Variable} & {\bf Name in the code} & {\bf LLR} & 
{\bf DE405/DE406} \\
\hline
  $\Delta W_1^{(0)}$ & {\tt Dw1\_0} & $-0.10525''$ & $-0.07008''$ \\
  $\Delta W_2^{(0)}$ & {\tt Dw2\_0} & $+0.16826''$ & $+0.20794''$ \\
  $\Delta W_3^{(0)}$ & {\tt Dw3\_0} & $-0.10760''$ & $-0.07215''$ \\
  $\Delta W_1^{(1)}$ & {\tt Dw1\_1} & $-0.32311''/{\rm cy}$ & $-0.35106''/{\rm cy}$ \\
  $\Delta W_2^{(1)}$ & {\tt Dw2\_1} & $+0.08017''/{\rm cy}$ & $+0.08017''/{\rm cy}$ \\
  $\Delta W_3^{(1)}$ & {\tt Dw3\_1} & $-0.04317''/{\rm cy}$ & $-0.04317''/{\rm cy}$ \\
  $\Delta W_1^{(2)}$ & {\tt Dw1\_2} & $-0.03794''/{\rm cy}^2$ & $-0.03743''/{\rm cy}^2$ \\
  $\Delta \Gamma$ & {\tt Dgam} & $+0.00069''$ & $+0.00085''$ \\ 
  $\Delta E$ & {\tt De} & $+0.00005''$ & $-0.00006''$ \\
  $\Delta T^{(0)}$ & {\tt Deart\_0} & $-0.04012''$ & $-0.00033''$ \\
  $\Delta T^{(1)}$ & {\tt Deart\_1} & $+0.01442''/{\rm cy}$ & $+0.00732''/{\rm cy}$ \\
  $\Delta \varpi^{'(0)}$ & {\tt Dperi} & $-0.04854''$ & $-0.00749''$ \\
  $\Delta e'$ & {\tt Dep} & $+0.00226''$ & $+0.00224''$ \\
  $\Delta W_1^{(3)}$ & {\tt Dw1\_3} & $0$ & $-0.00018865''/{\rm cy}^3$ \\
  $\Delta W_1^{(4)}$ & {\tt Dw1\_4} & $0$ & $-0.00001024''/{\rm cy}^4$ \\
  $\Delta W_2^{(2)}$ & {\tt Dw2\_2} & $0$ & $+0.00470602''/{\rm cy}^2$ \\
  $\Delta W_2^{(3)}$ & {\tt Dw2\_3} & $0$ & $-0.00025213''/{\rm cy}^3$ \\
  $\Delta W_3^{(2)}$ & {\tt Dw3\_2} & $0$ & $-0.00261070''/{\rm cy}^2$ \\
  $\Delta W_3^{(3)}$ & {\tt Dw3\_3} & $0$ & $-0.00010712''/{\rm cy}^3$ \\
\hline
\end{tabular}

\vskip 0.5cm
Here cy denotes Julian century. Note that the last 6 variables in the DE405/DE406 
column are used to make ELP/MPP02 approaches closely the JPL Ephemeris DE406 on 
a long range (a few seconds over 6 millennia), whereas the rest are fitted to DE405 
only. 

There are 8 more parameters needed. To calculate them, the following 
constants are calculated first.
\vskip 0.5cm
\begin{tabular}{ccc} 
  \hline 
 $j$ & $B'_{2,j}$ & $B'_{3,j}$ \\ 
\hline
  1 & 0.311079095 & -0.103837907 \\ 
  2 & -0.004482398 & 0.000668287 \\ 
  3 & -0.001102485 & -0.001298072 \\
  4 & 0.001056062 & -0.000178028 \\ 
  5 & 0.000050928 & -0.000037342 \\
\hline
\end{tabular}
\beqn
  m &=& n'/\nu = 0.074801329 , \cr
  \alpha &=& a_0/a' = 0.002571881, \cr 
  W_1^{(1)} &=& 1732559343.73604''/{\rm cy} + \Delta W_1^{(1)} , \cr 
  W_2^{(1)} &=& 14643420.3171''/{\rm cy} + \Delta W_2^{(1)} , \cr 
  W_3^{(1)} &=& -6967919.5383''/{\rm cy} + \Delta W_3^{(1)} , \cr
  \delta \nu &=& 0.55604''/{\rm cy} + \Delta W_1^{(1)} , \cr 
  \delta \Gamma &=& -0.08066'' + \Delta \Gamma , \cr 
  \delta E &=& 0.01789'' + \Delta E , \cr
  \delta e' &=& -0.12879'' + \Delta e' , \cr
  \delta n' &=& -0.0642''/{\rm cy} + \Delta T^{(1)} . \nonumber
\eeqn

The following are the equations for the 8 remaining parameters. 
\beqn
  \delta W_2^{(1)} &=& \left[ \frac{W_2^{(1)}}{W_1^{(1)}} - m\left( B'_{2,1} 
+ \frac{2\alpha}{3m}B'_{2,5}\right) \right] \Delta W_1^{(1)} + \left( 
B'_{2,1} + \frac{2\alpha}{3m}B'_{2,5}\right) \Delta T^{(1)} \cr \cr 
&&+ W_1^{(1)} (B'_{2,2} \Delta \Gamma + B'_{2,3} \Delta E + B'_{2,4} \Delta e') \cr \cr 
  \delta W_3^{(1)} &=& \left[ \frac{W_3^{(1)}}{W_1^{(1)}} - m\left( B'_{3,1}
+ \frac{2\alpha}{3m}B'_{3,5}\right) \right] \Delta W_1^{(1)} + \left(
B'_{3,1} + \frac{2\alpha}{3m}B'_{3,5}\right) \Delta T^{(1)} \cr \cr
&&+ W_1^{(1)} (B'_{3,2} \Delta \Gamma + B'_{3,3} \Delta E + B'_{3,4} \Delta e') \cr \cr 
  f_A &=& 1 - \frac{2 \delta \nu}{3 W_1^{(1)}} \cr \cr 
  f_{B1} &=& \frac{\delta n' - m\delta \nu}{W_1^{(1)}} \cr \cr 
  f_{B2} &=& \delta \Gamma \ \ \mbox{ (in radians)} \cr 
  f_{B3} &=& \delta E \ \ \mbox{ (in radians)} \cr 
  f_{B4} &=& \delta e' \ \ \mbox{ (in radians)} \cr \cr
  f_{B5} &=& \frac{2\alpha}{3m W_1^{(1)}} (\delta n' - m \delta \nu) . \nonumber
\eeqn

The first 21 parameters $\Delta W_1^{(0)}$, $\Delta W_2^{(0)}$, $\Delta W_3^{(0)}$, 
$\Delta W_1^{(1)}$, $\Delta W_2^{(1)}$, $\Delta W_3^{(1)}$, $\Delta W_1^{(2)}$, 
$\Delta \Gamma$, $\Delta E$, $\Delta T^{(0)}$, $\Delta T^{(1)}$, $\Delta \varpi'^{(0)}$, 
$\Delta e'$, $\Delta W_1^{(3)}$, $\Delta W_1^{(4)}$, $\Delta W_2^{(2)}$, 
$\Delta W_2^{(3)}$, $\Delta W_3^{(2)}$, $\Delta W_3^{(3)}$, $\delta W_2^{(1)}$, 
and $\delta W_3^{(1)}$ are grouped together in the struct {\tt Elp\_paras} 
in the C++ file {\tt ElpMpp02.h}. The last 6 parameters $f_A$, $f_{B1}$, $f_{B2}$, 
$f_{B3}$, $f_{B4}$, and $f_{B5}$ are grouped in the struct {\tt Elp\_facs} 
in {\tt ElpMpp02.h}. These 27 parameters are fixed once LLR or DE405/DE406 are 
specified. They only need to be computed once. 

These parameters are calculated in the subroutine \\
{\tt setup\_parameters(int corr, Elp\_paras \&paras, Elp\_facs \&facs)} \\
Parameters fitted to LLR are computed if {\tt corr} is 0 and parameters
fitted to DE405/DE406 are computed if {\tt corr} is 1. These groupings are 
convenient if one wants to construct other sets of parameters fitted to 
other data (e.g.\ DE431).

\subsection{Coefficients of the ELP/MPP02 Series}
\label{sec:ElpCoefs}

The coefficients are stored in the 14 data files: 

{\tt elp\_main.long}, {\tt elp\_main.lat}, {\tt elp\_main.dist}, 

{\tt elp\_pert.longT0}, {\tt elp\_pert.longT1}, {\tt elp\_pert.longT2}, 
{\tt elp\_pert.longT3},

{\tt elp\_pert.latT0}, {\tt elp\_pert.latT1}, {\tt elp\_pert.latT2}, 

{\tt elp\_pert.distT0}, {\tt elp\_pert.distT1}, {\tt elp\_pert.distT2}, 
{\tt elp\_pert.distT3}. 

They are 
constructed from the data files on 
\href{ftp://cyrano-se.obspm.fr/pub/2_lunar_solutions/2_elpmpp02/}{this ftp site} 
and put in a format more convenient for C++ implementation. 
In each file, the 
first line is an integer indicating the number of terms in the series. 

The first three files {\tt elp\_main.long}, {\tt elp\_main.lat}, and 
{\tt elp\_main.dist} are the Fourier series of the longitude, latitude and distance. 
They contain 11 columns containing 
\[
\{ i_1, i_2, i_3, i_4, A, B_1, B_2, B_3, B_4, B_5, B_6\} .
\]
The series is calculated by the equation 
\beq
  \sum_{\{ i\} } \tilde{A}_{\{ i \}} \left\{ \begin{array}{l} \sin \\ \cos \end{array}
\right \} 
(i_1 D + i_2 F + i_3 l + i_4 l') \ \ \ \{ i \} = \{ i_1, i_2, i_3, i_4 \} .
\eeq
Longitude and latitude are sine series and distance is cosine series. The 4 variables 
$D$, $F$, $l$ and $l'$ are the Delaunay arguments (see the next subsection). The coefficients 
$\tilde{A}_{\{ i \}}$ are calculated according to 
\beqn
  \tilde{A}_{\{ i \}} = \left \{ \begin{array}{ll} 
A_{\{ i \}} + \sum\limits_{j=1}^5 f_{Bj} B_{j\{ i \}} & \mbox{ for longitude and latitude} \\  \\
f_A A_{\{ i \}} + \sum\limits_{j=1}^5 f_{Bj} B_{j\{ i \}} & \mbox{ for distance} \end{array}\right. ,
\eeqn
where $f_A$ and $f_{Bj}$ ($j=1,2,3,4,5$) are the paremeters described in the previous 
subsection. They are grouped together in the struct {\tt Elp\_facs} in {\tt ElpMpp02.h}. 
Note that $B_{6 \{i \}}$ are not used in the calculation. In additional, the amplitudes
$A_{\{ i \}}$ for longitude and latitude are in arcseconds in the original data 
files. I converted them to radians in the files {\tt elp\_main.long} and 
{\tt elp\_main.lat}.

The remaining 11 files contain the Poisson series for perturbations. Each file 
has 15 columns containing $i_1$, $i_2$, ..., $i_{13}$, $A$ and $\phi_0$. The series 
is summed according to the equation 
\beq
  \sum_{\{i\}} A_{\{i\}} \sin \phi \ \ \ \{i\} = \{ i_1, i_2, ..., i_{13} \} ,
\eeq
The phase $\phi$ is given by 
\beq 
  \phi = \phi_0 + i_1 D + i_2 F + i_3 l + i_4 l' + i_5 Me + i_6 Ve + i_7 EM + i_8 Ma 
+ i_9 Ju + i_{10} Sa + i_{11} Ur + i_{12} Ne + i_{13} \zeta ,
\label{eq:phi}
\eeq
where the 13 arguments $D$, $F$, ... will be described in the next subsection. 
In the longitude and latitude files, the amplitudes $A_{\{i\}}$ are in 
${\rm radians}/{\rm cy}^n$. In all perturbation files, The initial phase 
$\phi_{0 \{i \}}$ are in radians.

The amplitudes $\tilde{A}_{\{i\}}$ in the main problem are fixed once the 
adjustable parameters fitted to LLR or DE405/DE406 are determined. The 
amplitudes $A_{\{i\}}$ in the Poisson series 
for perturbations are the same for the LLR and DE405/DE406 parameters. Hence, all 
coefficients are determined once LLR or DE405/DE406 are specified. The coefficients 
are calculated after the parameters in the previous subsection are calculated. 
They are grouped together in the struct {\tt Elp\_coefs} in {\tt ElpMpp02.h}. 

The coefficients are calculated in the subroutine \\
{\tt setup\_Elp\_coefs(Elp\_coefs \&coefs, Elp\_facs facs)}

\subsection{Lunar and Planetary Arguments} 

The Moon and Earth-Moon arguments are given by 
\beqn
  W_1 &=& (218^\circ 18' 59.95571'' + \Delta W_1^{(0)}) + 
(1732559343.73604''/{\rm cy} + \Delta W_1^{(1)}) T  \cr
&& + (-6.8084''/{\rm cy}^2 + \Delta W_1^{(2)}) T^2 
+ (0.006604''/{\rm cy}^3 + \Delta W_1^{(3)}) T^3 \cr
&&+ (-0.00003169''/{\rm cy}^4 + \Delta W_1^{(4)}) T^4 \\ 
  W_2 &=& (83^\circ 21' 11.67475'' + \Delta W_2^{(0)}) +
(14643420.3171''/{\rm cy} + \Delta W_2^{(1)} +\delta W_2^{(1)}) T  \cr
&& + (-38.2631''/{\rm cy}^2 + \Delta W_2^{(2)}) T^2
+ (-0.045047''/{\rm cy}^3 + \Delta W_2^{(3)}) T^3 \cr
&&+(0.00021301''/{\rm cy}^4) T^4 \\ 
  W_3 &=& (125^\circ 2' 40.39816'' + \Delta W_3^{(0)}) + 
(-6967919.5383''/{\rm cy} + \Delta W_3^{(1)} +\delta W_3^{(1)}) T  \cr
&& + (6.359''/{\rm cy}^2 + \Delta W_3^{(2)}) T^2
+ (0.007625''/{\rm cy}^3 + \Delta W_3^{(3)}) T^3 \cr
&&+(-0.00003586''/{\rm cy}^4) T^4 \\
  Ea &=& (100^\circ 27' 59.13885'' + \Delta T^{(0)}) +
(129597742.293''/{\rm cy} + \Delta T^{(1)}) T  \cr
&& + (-0.0202''/{\rm cy}^2) T^2
+ (9''\times 10^{-6}/{\rm cy}^3) T^3 \cr
&&+ (1.5''\times 10^{-7}/{\rm cy}^4) T^4 \\
  \varpi' &=& (102^\circ 56' 14.45766'' + \Delta \varpi'^{(0)}) + 
(1161.24342''/{\rm cy}) T + (0.529265''/{\rm cy}^2) T^2 \cr 
&& - (1.1814''\times 10^{-4}/{\rm cy}^3) T^3 + (1.1379''\times 10^{-5}/{\rm cy}^4) T^4 ,
\eeqn
where $T=({\rm JD}-2451545)/36525$ is the barycentric dynamical time (TDB) in
Julian centuries from J2000.0

Delaunay arguments $D$, $F$, $l$ and $l'$ are given by 
\beqn
  D &=& W_1 - Ea + 180^\circ \\ 
  F &=& W_1-W_3 \\ 
  l &=& W_1-W_2 \\ 
  l' &=& Ea - \varpi' .
\eeqn
These are the 4 arguments appearing in the ELP/MPP02 series for the main problem, 
and also the first 4 arguments appearing in the ELP/MPP02 series for perturbations. 
The remaining 9 arguments in the ELP/MPP02 series for perturbations are given by 
\beqn
  Me &=& 252^\circ 15' 3.216919'' + (538101628.66888''/{\rm cy}) T \\ 
  Ve &=& 181^\circ 58' 44.758419'' + (210664136.45777''/{\rm cy}) T \\ 
  EM &=& 100^\circ 27' 59.13885'' + (129597742.293''/{\rm cy}) T \\
  Ma &=& 355^\circ 26' 3.642778'' + (68905077.65936''/{\rm cy}) T \\ 
  Ju &=& 34^\circ 21' 5.379392'' + (10925660.57335''/{\rm cy}) T \\ 
  Sa &=& 50^\circ 4' 38.902495'' + (4399609.33632''/{\rm cy}) T \\ 
  Ur &=& 314^\circ 3' 4.354234'' + (1542482.57845''/{\rm cy}) T \\
  Ne &=& 304^\circ 20' 56.808371'' + (786547.897''/{\rm cy}) T \\ 
  \zeta &=& W_1 + (5028.79695''/{\rm cy}) T .
\eeqn

These 13 arguments are grouped together in the struct {\tt Elp\_args} in 
{\tt ElpMpp02.h}. They are calculated in the subroutine \\
{\tt compute\_Elp\_arguments(double T, Elp\_paras paras, Elp\_args \&args)}

\subsection{Position of the Moon} 

The natural coordinate system in ELP/MPP02 theory is based on the mean ecliptic 
of date. In this coordinate system, the geocentric ecliptic longitude $V$, 
latitude $U$ and distance $r$ of the Moon are given by 
\beqn
  V &=& W_1 + \mbox{series({\tt elp\_main.long})} + \mbox{series({\tt elp\_pert.longT0})} + 
\mbox{series({\tt elp\_pert.longT1})}\cdot T \cr 
&&+ \mbox{series({\tt elp\_pert.longT2})}\cdot T^2 + \mbox{series({\tt elp\_pert.longT3})}\cdot T^3 \\
  U &=& \mbox{series({\tt elp\_main.lat})} + \mbox{series({\tt elp\_pert.latT0})} +
\mbox{series({\tt elp\_pert.latT1})}\cdot T \cr
&&+ \mbox{series({\tt elp\_pert.latT2})}\cdot T^2 \\ 
  r &=& r_{a0} \cdot [\mbox{series({\tt elp\_main.dist})} + \mbox{series({\tt elp\_pert.distT0})} +
\mbox{series({\tt elp\_pert.distT1})}\cdot T \cr
&&+ \mbox{series({\tt elp\_pert.distT2})}\cdot T^2 + \mbox{series({\tt elp\_pert.distT3})}\cdot T^3] ,
\eeqn
where $r_{a0}=a_0({\rm DE405})/a_0({\rm ELP}) = 384747.961370173/384747.980674318$. 
The rectrangular coordinates $X$, $Y$, $Z$ with respect to the mean ecliptic and equinox 
of J2000.0 are given by
\beq
\left( \begin{array}{c} X \\ Y \\ Z\end{array}\right)
  \left( \begin{array}{ccc} 
1-2P^2 & 2PQ & 2P\sqrt{1-P^2-Q^2} \\ 
2PQ & 1-2Q^2 & -2Q\sqrt{1-P^2-Q^2} \\ 
-2P\sqrt{1-P^2-Q^2}  & 2Q\sqrt{1-P^2-Q^2} & 1-2P^2-2Q^2 \end{array}\right)
\left( \begin{array}{c} r \cos V \cos U \\ r \sin V \cos U \\ r \sin U \end{array}\right) ,
\eeq
where
\beqn
  P &=& 0.10180391 \times 10^{-4} T + 0.47020439\times 10^{-6} T^2 
- 0.5417367\times 10^{-9} T^3 \cr 
&& - 0.2507948\times 10^{-11} T^4 + 0.463486\times 10^{-14} T^5 \\ 
  Q &=& -0.113469002\times 10^{-3} T + 0.12372674\times 10^{-6} T^2 
+ 0.1265417\times 10^{-8} T^3 \cr 
&& - 0.1371808\times 10^{-11} T^4 - 0.320334\times 10^{-14} T^5 .
\eeqn

Rectangular coordinates $X$, $Y$ and $Z$ are computed in {\tt ElpMpp02.h} 
in the subroutine \\
{\tt getX2000(double T,  Elp\_paras \&paras, Elp\_coefs \&coefs,
              double \&X, double \&Y, double \&Z)}

\subsection{Test Cases}

Test cases are provided in the pdf document on 
\href{ftp://cyrano-se.obspm.fr/pub/2_lunar_solutions/2_elpmpp02/}{this ftp site}. 
Here I provide another sets of cases for code test. 

\vskip 0.5cm
Lunar geocentric rectangular coordinates (ecliptic and equinox of J2000.0) using 
parameters fitted to LLR.

\begin{tabular}{ccccc}
\hline
 TDB JD & \begin{tabular}{c} TDB Date, Time \\ (YYYY-MM-DD, HH:MM:SS)\end{tabular} 
& X (km) & Y (km) & Z (km) \\ 
\hline
  2444269.5 & 1980-01-31, 00:00:00 & -186813.01288 & 349310.13512 & -19003.33883 \\ 
  2446269.7 & 1985-07-23, 04:48:00 & -367970.07950 & -45234.88375 & 20221.87153 \\ 
  2448269.9 & 1991-01-13, 09:36:00 & -38942.82455 & -403238.94206 & -20800.77410 \\ 
  2450270.1 & 1996-07-05, 14:24:00 & 357372.04971 & -89978.49535 & 14501.18831 \\ 
  2452270.3 & 2001-12-26, 19:12:00 & 252208.00739 & 294433.40162 & -21940.36333 \\ 
\hline
\end{tabular}

\vskip 0.5cm
Lunar geocentric rectangular coordinates (ecliptic and equinox of J2000.0) using
parameters fitted to DE405/DE406.

\begin{tabular}{ccccc}
\hline
 TDB JD & \begin{tabular}{c} TDB Date, Time \\ (YYYY-MM-DD, HH:MM:SS)\end{tabular}
& X (km) & Y (km) & Z (km) \\
\hline
  2521835.67 & 2192-06-13, 04:04:48 & -184108.21468 & 345893.25529 & 30395.06868 \\
  2265621.33 & 1490-12-07, 19:55:12 & -298024.37832 & -213909.67132 & -23263.21426 \\
  2009406.99 & 0789-06-16, 11:45:36 & 350041.24745 & -201093.28987 & 1643.33539 \\
  1753192.65 & 0087-12-25, 03:36:00 & 90272.39894 & 351997.39617 & 13417.01712 \\
  1496978.31 & -0614-07-03, 19:26:24 & -403018.01560 & -2639.93889 & -28463.89733 \\
\hline
\end{tabular}

More test cases can be generated by modifying the C++ code {\tt example.cpp} or using 
this \href{https://github.com/ytliu0/ElpMpp02/ElpMpp02.html}{JavaScript calculator}.

\section{Truncated ELP/MPP02 Series}

\subsection{Implementation}

The ELP/MPP02 series can be written in the form 
\beqn
V(T) &=& W_1(T) + \sum_{i=0}^3 T^i \sum_j A^{(V)}_{ij} \sin\left[ \phi^{(V)}_{ij}(T)\right] \\
  U(T) &=& \sum_{i=0}^2 T^i \sum_j A^{(U)}_{ij} \sin\left[ \phi^{(U)}_{ij}(T)\right] \\
  r(T) &=& \sum_{i=0}^3 T^i \sum_j A^{(r)}_{ij} \sin\left[ \phi^{(r)}_{ij}(T)\right] ,
\label{eq:Dmoon}
\eeqn 
where $A^{(U)}_{ij}$, $A^{(V)}_{ij}$, $A^{(r)}_{ij}$ are constant amplitudes 
once the adjustable parameters are chosen. The phase angles 
$\phi^{(U)}_{ij}$, $\phi^{(V)}_{ij}$, $\phi^{(r)}_{ij}$ are linear functions
of 13 arguments (see Section~\ref{sec:ElpCoefs}). 

I construct a truncated series by the following procedure:

\begin{itemize}
\item Choose four parameters $A^{(U)}_{\rm th}$, $A^{(V)}_{\rm th}$,
$A^{(r)}_{\rm th}$ and $\tau$.

\item Drop the terms in the series with $A^{(U)}_{ij} < A^{(U)}_{\rm th} /\tau^i$,
$A^{(V)}_{ij} < A^{(V)}_{\rm th} /\tau^i$, and
$A^{(r)}_{ij} < A^{(r)}_{\rm th} /\tau^i$.
\end{itemize}

It is clear that the smaller the parameters $A^{(U)}_{\rm th}$, $A^{(V)}_{\rm th}$,
and $A^{(r)}_{\rm th}$, the closer the truncated series is to the original series.
The parameter $\tau$ has a unit of time and should be chosen to cover the time span 
of interest.

The truncation is implemented in the file {\tt ElpMpp\_trim.h} by the subroutine \\
{\tt trim\_Elp\_coefs(Elp\_coefs \&coefs, Elp\_coefs \&coefs\_trim,
                    double AthU, double AthV, double AthR, double tau)} \\
where {\tt coefs} is a struct containing the coefficients of the full series. 
Coefficients of the truncated series will be written to the struct {\tt coefs\_trim}. 
This new struct can be passed to the function {\tt getX2000()} to 
compute the Moon's position using the truncated series.

\subsection{Accuracy of Truncated Series}

One simple way to estimate the accuracy of a truncated series is to calculate the 
sum of the absolute value of the amplitudes of the dropped terms. This gives the 
maximum deviation the truncated series could be from the full series. Suppose the 
truncated series is to be used in the time span $T_1 < T < T_2$, the maximum possible 
deviations between the full and truncated series are
\beqn
  \Delta V_{\rm max} &=& \sum_{i=0}^3 T_{\rm max}^i \sum_{\rm dropped~{A_{ij}^{(V)}}} |A_{ij}^{(V)}| \label{eq:DeltaVmax} \\
  \Delta U_{\rm max} &=& \sum_{i=0}^2 T_{\rm max}^i \sum_{\rm dropped~{A_{ij}^{(U)}}} |A_{ij}^{(U)}| \label{eq:DeltaUmax} \\
  \Delta r_{\rm max} &=& \sum_{i=0}^3 T_{\rm max}^i \sum_{\rm dropped~{A_{ij}^{(r)}}} |A_{ij}^{(r)}| , \label{eq:Deltarmax}
\eeqn
where $T_{\rm max} = {\rm max}(|T_1|, |T_2|)$. These estimated deviations are 
very conservative because 
in general the phases in the terms are difference and the terms do not have the same sign. 
Root mean square deviations may provide better estimates of typical deviations at any 
given time between $T_1$ and $T_2$: 
\beq
 rms(\Delta q) = \sqrt{ \langle \Delta q^2(T) \rangle}  = \sqrt{ \left\langle \sum_{i=0}^3 \sum_{j=0}^3 T^{i+j} 
\sum_{\rm dropped~{A_{ik}^{(q)}}} \sum_{\rm dropped~{A_{jm}^{(q)}}} 
A_{ik}^{(q)} A_{jm}^{(q)} \sin \phi_{ik}^{(q)}(T) \sin \phi_{jm}^{(q)}(T) \right\rangle } ,
\eeq
where $q=U,V,r$ and $\langle \rangle$ denotes time average. Assume that the time 
average of the cross terms are small, which might not be true, the expression 
may be simplified to 
\beq
  rms(\Delta q) \approx \sqrt{ \sum_{i=0}^3 \frac{T_2^{2i+1}-T_1^{2i+1}}{2(2i+1)(T_2-T_1)} 
\sum_{\rm dropped~{A_{ij}^{(q)}}} \left( A_{ij}^{(q)}\right)^2 } ,
\label{eq:rmsDeltaq}
\eeq
where I have used the approximation that 
\beq
  \left\langle T^{2i} \sin^2 \phi_{ij}^{(q)} \right\rangle \approx 
\left\langle T^{2i}  \right\rangle \left\langle \sin^2 \phi_{ij}^{(q)}(T) \right\rangle 
\approx \frac{T_2^{2i+1}-T_1^{2i+1}}{2(2i+1)(T_2-T_1)} .
\eeq
The validity of this approximation is also uncertain. There is also an implicit  
assumption that any time between $T_1$ and $T_2$ is equally likely to be chosen. 
Whether or not this assumption is valid depends on specific applications. For example, one 
may want to use a truncated series to calculate lunar positions between 1900 and 2100 
($T_1=-1$, $T_2=1$)
most of the time, but occasionally may want to calculate the positions in ancient times. 
If this is the case, one should choose multiple pairs of $(T_1, T_2)$ and 
estimate the accuracy of the truncated series in those time intervals.

A more reliable way of estimating the accuracy is to perform a Monte Carlo simulation, 
in which values of $V$, $U$, $r$ are calculated from both the full series and truncated 
series at $n$ randomly chosen times between $T_1$ and $T_2$. The deviations 
are then estimated according to the equations 
\beqn
  \Delta q_{\rm max} &\approx& {\rm max}(|\Delta q_1|, |\Delta q_2|, \cdots, |\Delta q_n|) 
\label{eq:DeltaqmaxMC} \\
  rms(\Delta q) &\approx & = \sqrt{ \frac{1}{n}\sum_{i=0}^n (\Delta q_i)^2 } ,
\label{DeltaqrmsMC}
\eeqn
where 
\beq
  \Delta q_i = q_{\rm full~series}(T_i) - q_{\rm truncated~series}(T_i) 
= \sum_{k=0}^3 T_i^k \sum_{\rm dropped~{A_{kj}^{(q)}}} A_{kj}^{(q)} 
\sin \phi_{kj}^{(q)}(T_i) .
\eeq

The crude error estimates from equations~(\ref{eq:DeltaVmax}),
(\ref{eq:DeltaUmax}), (\ref{eq:Deltarmax}) and (\ref{eq:rmsDeltaq}) are implemented 
in {\tt ElpMpp\_trim.h} in subroutine \\
{\tt trim\_Elp\_coefs\_errorEst(Elp\_coefs \&coefs, Elp\_coefs \&coefs\_trim, Elp\_coefs \&coefs\_drop,
                    double AthU, double AthV, double AthR, double tau,
                    double T1, double T2, devStats \&stats)} \\
where {\tt coefs\_drop} stores the dropped coefficients and 
{\tt devStats} is a struct grouping the variables for $\Delta q_{\rm max}$ 
and $rms(\Delta q)$. 

The error estimate based on a Monte Carlo (MC) simulation is implemented in 
{\tt ElpMpp\_trim.h} in subroutine \\
{\tt error\_est(Elp\_coefs \&coefs\_drop, Elp\_paras \&paras,
               int n, double T1, double T2, devStats \&errStats)} 

I set $n=10000$ for a typical run to obtain decent statistics. It may 
take a while to complete the simulation, depending on your processor speed. 
I use the {\tt rand()} function in {\tt <cstdlib>} to generate random numbers.
In my Linux g++ compiler, {\tt rand()} generates pseudo random integers between 
0 and 2147483647.
A seed is currently set using {\tt srand(4852618)} in the code to ensure reproducibility. 
It is not clear to me that {\tt rand()/2147483647} will produce random 
numbers uniformly distributed between 0 and 1, but the result I get from 
using {\tt rand()} seems to agree with that 
obtained from pseudo random numbers generated by R's {\tt runif()} function, which 
generates pseudo random numbers uniformly distributed between 0 and 1.

The following are examples of error estimates computed from the two subroutines.

\vskip 0.5cm
In all cases, $\tau=50$, $T_1=-50$, $T_2=10$ and parameters fitted to DE405/DE406 are 
used. $N$ is the 
number of terms in the truncated Elp/MPP02 series. $\Delta q_{\rm max}$ 
and $rms(\Delta q)$ ($q=V,U,r$) are computed from equations~(\ref{eq:DeltaVmax}), 
(\ref{eq:DeltaUmax}), (\ref{eq:Deltarmax}) and (\ref{eq:rmsDeltaq}). 

\begin{tabular}{cccccccccc}
\hline
  $A_{\rm th}^{(U)}$ & $A_{\rm th}^{(V)}$ & $A_{\rm th}^{(r)}$ & $N$ &
  $\Delta V_{\rm max}$ & $rms(\Delta V)$ & $\Delta U_{\rm max}$ & $rms(\Delta U)$
  & $\Delta r_{\rm max}$ & $rms(\Delta r)$ \\
\hline
  $30''$ & $30''$ & 100~km & 42 & $422''$ & $45.4''$ & $209''$ & $32.5''$ & 462~km &
84.0~km \\
  $10''$ & $10''$ & 20~km & 69 & $242''$ & $20.5''$ & $137''$ & $17.6''$ & 282~km &
30.5~km \\
  $1''$ & $1''$ & 2~km & 187 & $74''$ & $2.95''$ & $38.6''$ & $3.34''$ & 60.2~km &
3.96~km \\
  $0.001''$ & $0.001''$ & 0.1~km & 3759 & $1.47''$ & $0.016''$ & $0.80''$ & $0.015''$ &
  16.3~km & 0.42~km \\
\hline
\end{tabular}

\vskip 0.5cm
Same as above, but $\Delta q_{\rm max}$
and $rms(\Delta q)$ are estimated by Monte Carlo simulations using 
equations~(\ref{eq:DeltaqmaxMC}) 
and (\ref{DeltaqrmsMC}) with $n=10000$. All $\Delta q_{\rm max}$ and 
$rms(\Delta q)$ are rounded to two significant figures, which is about the 
accuracy of the estimates using $n=10000$.

\begin{tabular}{cccccccccc}
\hline
  $A_{\rm th}^{(U)}$ & $A_{\rm th}^{(V)}$ & $A_{\rm th}^{(r)}$ & $N$ &
  $\Delta V_{\rm max}$ & $rms(\Delta V)$ & $\Delta U_{\rm max}$ & $rms(\Delta U)$ 
  & $\Delta r_{\rm max}$ & $rms(\Delta r)$ \\
\hline
  $30''$ & $30''$ & 100~km & 42 & $230''$ & $48''$ & $150''$ & $34''$ & 340~km & 
86~km \\
  $10''$ & $10''$ & 20~km & 69 & $100''$ & $21''$ & $98''$ & $19''$ & 150~km & 
31~km \\
  $1''$ & $1''$ & 2~km & 187 & $17''$ & $3.0''$ & $18''$ & $2.4''$ & 17~km & 
4.3~km \\ 
  $0.001''$ & $0.001''$ & 0.1~km & 3759 & $0.093''$ & $0.016''$ & $0.058''$ & $0.012''$ & 
  2.0~km & 0.42~km \\
\hline
\end{tabular}

\vskip 0.5cm
Not surprisingly, $\Delta q_{\rm max}$ calculated by ~(\ref{eq:DeltaVmax}),
(\ref{eq:DeltaUmax}), (\ref{eq:Deltarmax}) are always larger than those estimated by 
MC, but the estimates for $rms(\Delta q)$ by both methods turn out to be quite 
close for the cases considered.

Note that the accuracy is estimated by comparing the truncated series to 
the full series. One might want to compare the truncated series to other 
data such as JPL's ephemerides. The Monte Carlo subroutine can be modified 
to make that comparison. 
In the following, I show results of comparison between the truncated series and 
JPL's DE406 and DE431 in the time intervals $-50 < T <10$. 

\vskip 0.5cm
In all cases, $\tau=50$, $T_1=-50$, $T_2=10$ and parameters fitted to DE405/DE406 are
used. The series is now compared to JPL's DE406 using Monte Carlo method with 
$n=10000$. The case with $A_{\rm th}^{(U)}=A_{\rm th}^{(V)}=A_{\rm th}^{(r)}=0$ 
is the untruncated series.

\begin{tabular}{cccccccccc}
\hline
  $A_{\rm th}^{(U)}$ & $A_{\rm th}^{(V)}$ & $A_{\rm th}^{(r)}$ & $N$ &
  $\Delta V_{\rm max}$ & $rms(\Delta V)$ & $\Delta U_{\rm max}$ & $rms(\Delta U)$
  & $\Delta r_{\rm max}$ & $rms(\Delta r)$ \\
\hline
  $30''$ & $30''$ & 100~km & 42 & $230''$ & $47''$ & $150''$ & $34''$ & 370~km &
86~km \\
  $10''$ & $10''$ & 20~km & 69 & $97''$ & $21''$ & $100''$ & $19''$ & 150~km &
31~km \\
  $1''$ & $1''$ & 2~km & 187 & $15''$ & $2.9''$ & $14''$ & $2.4''$ & 17~km &
4.3~km \\
  $0.001''$ & $0.001''$ & 0.1~km & 3759 & $3.5''$ & $0.56''$ & $0.59''$ & $0.10''$ &
  2.6~km & 0.46~km \\
  0 & 0 & 0 & 35901 & $3.5''$ & $0.56''$ & $0.59''$ & $0.10''$ & 1.3~km & 0.19~km \\
\hline
\end{tabular}

\vskip 0.5cm
Same as the previous table but the comparison is to JPL's DE431.

\begin{tabular}{cccccccccc}
\hline
  $A_{\rm th}^{(U)}$ & $A_{\rm th}^{(V)}$ & $A_{\rm th}^{(r)}$ & $N$ &
  $\Delta V_{\rm max}$ & $rms(\Delta V)$ & $\Delta U_{\rm max}$ & $rms(\Delta U)$
  & $\Delta r_{\rm max}$ & $rms(\Delta r)$ \\
\hline
  $30''$ & $30''$ & 100~km & 42 & $240''$ & $48''$ & $150''$ & $34''$ & 340~km &
86~km \\
  $10''$ & $10''$ & 20~km & 69 & $100''$ & $21''$ & $99''$ & $19''$ & 150~km &
31~km \\
  $1''$ & $1''$ & 2~km & 187 & $19''$ & $3.7''$ & $18''$ & $2.4''$ & 17~km &
4.3~km \\
  $0.001''$ & $0.001''$ & 0.1~km & 3759 & $12.5''$ & $2.5''$ & $1.5''$ & $0.33''$ &
  3.4~km & 0.53~km \\
  0 & 0 & 0 & 35901 & $12.5''$ & $2.5''$ & $1.5''$ & $0.33''$ &
  2.6~km & 0.33~km \\
\hline
\end{tabular}

\subsection{Saving the Truncated Series}

If you are happy with the truncated series, you may want to save the coefficients 
of the truncated series so that you don't have to recalculate them every time. 
A subroutine is provided in {\tt ElpMpp\_trim.h} to output the coefficients 
to 14 data files: \\
{\tt output\_data\_files(const char *dataFileSuffix, Elp\_coefs \&coefs)} \\
where {\tt coefs} is the struct that stores the truncated coefficients. All 
file names have the form {\tt elp\_MMMM.[X]dataFileSuffix}, where MMMM is 
main or pert, [X] can be long, lat, dist, longT0, longT1, longT2, longT3, 
latT0, latT1, latT2, distT0, distT1, distT2, distT3. {\tt dataFileSuffix} contains 
characters appended to the file name. It provides a shorthand notation
for the truncated series.

The format of the 14 files are almost the same as before. The first line is 
an integer indicating the number of terms in the series. The three files for the 
main problem each has 5 columns containing $i_1$, $i_2$, $i_3$, $i_4$ and 
$\tilde{A}$. There is no need to calculate $\tilde{A}$ from $A$ and $B_i$ since 
parameters have been chosen to fit either LLR or DE405/DE406 when constructing 
the truncated series. The remaining 11 files for perturbations are the same 
as before: 15 columns containing $i_1$, $i_2$, ..., $i_{13}$, $A$ and $\phi_0$. 

{\tt ElpMpp\_trim.h} also has a subroutine that generates a C++ code to compute 
the truncated series based on the 14 data files created by {\tt output\_data\_files()}. 
The subroutine is \\
{\tt generate\_cpp\_code(const char* outfile, const char *dataFileSuffix, int corr,
                       double AthU, double AthV, double AthR, double tau,
                       Elp\_paras \&paras)} \\
The file name of the C++ code is given by the character array {\tt outfile}. 

The file {\tt example\_usingElpMpp\_trim.cpp} provides an example of 
using {\tt ElpMpp\_trim.h} to generate a truncated ELP/MPP02 series, 
estimate its accuracy, save coefficients to data files and create a C++ code.

\section{JavaScript Code Generation}

JavaScript is convenient for HTML-based applications, such as my
\href{https://ytliu0.github.io/starCharts/}{local star charts} and 
\href{https://ytliu0.github.io/starCharts/chartGCRS_min.html}{equatorial star 
charts} pages. The file 
{\tt ElpMpp\_JavaScript.h} contains C++ subroutines that can 
generate JavaScript functions to compute a truncated ELP/MPP02 series. 
Instruction for the use of this code is at the beginning of the file. 
The two main subroutines are \\
{\tt generate\_javascript\_code(const char* outfile, int corr,
                       double AthU, double AthV, double AthR, double tau,
                       Elp\_paras \&paras, Elp\_coefs \&coefs, const char* funSuffix)} \\
and \\
{\tt generate\_javascript\_code\_min(const char* outfile, int corr,
                       double AthU, double AthV, double AthR, double tau,
                       Elp\_paras \&paras, Elp\_coefs \&coefs, const char *funSuffix)}\\
{\tt outfile} is file name of the js file that will be outputted. 
Characters in {\tt funSuffix} will be added to every JavaScript function. 
This is useful to prevent conflicts with code that implements other versions 
of the truncated series. The subroutine {\tt generate\_javascript\_code()} 
generates a human-readable js file. It is intended for your reference only. The 
subroutine {\tt generate\_javascript\_code\_min()} generates a minified 
version of the js file, in which comments and unnecessary white spaces are 
stripped to optimize performance. The js files generated by the two subroutines 
provide identical functions. 

Unlike the C++ code generator, no data files will be outputted. The ELP/MPP02 
series are written expliticly in the outputted js file instead of using loops. 
JavaScript is an interpreted language, not a compiled language. So it cannot 
take advantage of any loop parallization that may be available through compilers.
In addition, in the computation of phases such as 
in equation~(\ref{eq:phi}), many of the $i$'s are zeros. When writing out the series 
explicitly, all the zero $i$'s are removed to speed up computation. In fact, 
writing out the series explicitly may also benefit a C++ code, especially when the 
truncated series contains less than 1000 terms. The subroutines above can be 
modified easily to turn into a C++ code generator.

\href{https://github.com/ytliu0/ElpMpp02/ElpMpp02.html}{This JavaScript calculator} 
uses two js files {\tt ElpMpp02LLR\_min.js} and {\tt ElpMpp02DE\_min.js} to 
compute the ELP/MPP02 series. They are minified Javascript files generated using 
subroutines in {\tt ElpMpp\_JavaScript.h} by setting $A_{\rm th}^{(V)} = A_{\rm th}^{(U)}
= A_{\rm th}^{(r)} = 0$ and using parameters fitted to LLR and DE405/DE406.

The C++ file {\tt example\_usingElpMpp\_JavaScript.cpp} provides an example 
of using \\ {\tt ElpMpp\_JavaScript.h} to generate JavaScript functions to compute
a truncated ELP/MPP02 series.

\end{document}
